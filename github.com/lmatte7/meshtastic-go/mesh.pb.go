// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.15.6
// source: mesh.proto

package meshtastic_go

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

//*
// Note: these enum names must EXACTLY match the string used in the device
// bin/build-all.sh script.  Because they will be used to find firmware filenames
// in the android app for OTA updates.
// To match the old style filenames, _ is converted to -, p is converted to .
type HardwareModel int32

const (
	HardwareModel_UNSET          HardwareModel = 0
	HardwareModel_TLORA_V2       HardwareModel = 1
	HardwareModel_TLORA_V1       HardwareModel = 2
	HardwareModel_TLORA_V2_1_1p6 HardwareModel = 3
	HardwareModel_TBEAM          HardwareModel = 4
	HardwareModel_HELTEC         HardwareModel = 5
	HardwareModel_TBEAM0p7       HardwareModel = 6
	HardwareModel_T_ECHO         HardwareModel = 7
	HardwareModel_TLORA_V1_1p3   HardwareModel = 8
	HardwareModel_RAK4631        HardwareModel = 9
	// Less common/prototype boards listed here (needs one more byte over the air)
	HardwareModel_LORA_RELAY_V1 HardwareModel = 32
	HardwareModel_NRF52840DK    HardwareModel = 33
	HardwareModel_PPR           HardwareModel = 34
	HardwareModel_GENIEBLOCKS   HardwareModel = 35
	HardwareModel_NRF52_UNKNOWN HardwareModel = 36
	HardwareModel_PORTDUINO     HardwareModel = 37
	// The simulator built into the android app
	HardwareModel_ANDROID_SIM HardwareModel = 38
)

// Enum value maps for HardwareModel.
var (
	HardwareModel_name = map[int32]string{
		0:  "UNSET",
		1:  "TLORA_V2",
		2:  "TLORA_V1",
		3:  "TLORA_V2_1_1p6",
		4:  "TBEAM",
		5:  "HELTEC",
		6:  "TBEAM0p7",
		7:  "T_ECHO",
		8:  "TLORA_V1_1p3",
		9:  "RAK4631",
		32: "LORA_RELAY_V1",
		33: "NRF52840DK",
		34: "PPR",
		35: "GENIEBLOCKS",
		36: "NRF52_UNKNOWN",
		37: "PORTDUINO",
		38: "ANDROID_SIM",
	}
	HardwareModel_value = map[string]int32{
		"UNSET":          0,
		"TLORA_V2":       1,
		"TLORA_V1":       2,
		"TLORA_V2_1_1p6": 3,
		"TBEAM":          4,
		"HELTEC":         5,
		"TBEAM0p7":       6,
		"T_ECHO":         7,
		"TLORA_V1_1p3":   8,
		"RAK4631":        9,
		"LORA_RELAY_V1":  32,
		"NRF52840DK":     33,
		"PPR":            34,
		"GENIEBLOCKS":    35,
		"NRF52_UNKNOWN":  36,
		"PORTDUINO":      37,
		"ANDROID_SIM":    38,
	}
)

func (x HardwareModel) Enum() *HardwareModel {
	p := new(HardwareModel)
	*p = x
	return p
}

func (x HardwareModel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HardwareModel) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[0].Descriptor()
}

func (HardwareModel) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[0]
}

func (x HardwareModel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HardwareModel.Descriptor instead.
func (HardwareModel) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

//
// Shared constants between device and phone
type Constants int32

const (
	//
	// First enum must be zero, and we are just using this enum to
	// pass int constants between two very different environments
	Constants_Unused Constants = 0
	//
	// From mesh.options
	// note: this payload length is ONLY the bytes that are sent inside of the radiohead packet
	// Data.payload max_size:240
	Constants_DATA_PAYLOAD_LEN Constants = 240
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0:   "Unused",
		240: "DATA_PAYLOAD_LEN",
	}
	Constants_value = map[string]int32{
		"Unused":           0,
		"DATA_PAYLOAD_LEN": 240,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

//
// Error codes for critical errors
//
// The device might report these fault codes on the screen.
// If you encounter a fault code, please post on the meshtastic.discourse.group
// and we'll try to help.
type CriticalErrorCode int32

const (
	CriticalErrorCode_None CriticalErrorCode = 0
	//
	// A software bug was detected while trying to send lora
	CriticalErrorCode_TxWatchdog CriticalErrorCode = 1
	//
	// A software bug was detected on entry to sleep
	CriticalErrorCode_SleepEnterWait CriticalErrorCode = 2
	//
	// No Lora radio hardware could be found
	CriticalErrorCode_NoRadio CriticalErrorCode = 3
	//
	// Not normally used
	CriticalErrorCode_Unspecified CriticalErrorCode = 4
	//
	// We failed while configuring a UBlox GPS
	CriticalErrorCode_UBloxInitFailed CriticalErrorCode = 5
	//
	// This board was expected to have a power management chip and it is missing or broken
	CriticalErrorCode_NoAXP192 CriticalErrorCode = 6
	//
	// The channel tried to set a radio setting which is not supported by this chipset,
	// radio comms settings are now undefined.
	CriticalErrorCode_InvalidRadioSetting CriticalErrorCode = 7
	//
	// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
	// reply with an interrupt.
	CriticalErrorCode_TransmitFailed CriticalErrorCode = 8
	// We detected that the main CPU voltage dropped below the minumum acceptable value
	CriticalErrorCode_Brownout CriticalErrorCode = 9
)

// Enum value maps for CriticalErrorCode.
var (
	CriticalErrorCode_name = map[int32]string{
		0: "None",
		1: "TxWatchdog",
		2: "SleepEnterWait",
		3: "NoRadio",
		4: "Unspecified",
		5: "UBloxInitFailed",
		6: "NoAXP192",
		7: "InvalidRadioSetting",
		8: "TransmitFailed",
		9: "Brownout",
	}
	CriticalErrorCode_value = map[string]int32{
		"None":                0,
		"TxWatchdog":          1,
		"SleepEnterWait":      2,
		"NoRadio":             3,
		"Unspecified":         4,
		"UBloxInitFailed":     5,
		"NoAXP192":            6,
		"InvalidRadioSetting": 7,
		"TransmitFailed":      8,
		"Brownout":            9,
	}
)

func (x CriticalErrorCode) Enum() *CriticalErrorCode {
	p := new(CriticalErrorCode)
	*p = x
	return p
}

func (x CriticalErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CriticalErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[2].Descriptor()
}

func (CriticalErrorCode) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[2]
}

func (x CriticalErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CriticalErrorCode.Descriptor instead.
func (CriticalErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{2}
}

//
// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
// details on the type of failure).
type Routing_Error int32

const (
	//
	// This message is not a failure
	Routing_NONE Routing_Error = 0
	//
	// Our node doesn't have a route to the requested destination anymore.
	Routing_NO_ROUTE Routing_Error = 1
	//
	// We received a nak while trying to forward on your behalf
	Routing_GOT_NAK Routing_Error = 2
	Routing_TIMEOUT Routing_Error = 3
	//
	// No suitable interface could be found for delivering this packet
	Routing_NO_INTERFACE Routing_Error = 4
	//
	// We reached the max retransmission count (typically for naive flood routing)
	Routing_MAX_RETRANSMIT Routing_Error = 5
	//
	// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
	Routing_NO_CHANNEL Routing_Error = 6
	//
	// The packet was too big for sending (exceeds interface MTU after encoding)
	Routing_TOO_LARGE Routing_Error = 7
	//
	// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
	// (possibly due to bad channel permissions)
	Routing_NO_RESPONSE Routing_Error = 8
	//
	// The application layer service on the remote node received your request, but considered your request somehow invalid
	Routing_BAD_REQUEST Routing_Error = 32
	//
	// The application layer service on the remote node received your request, but considered your request not authorized (i.e you did not
	// send the request on the required bound channel)
	Routing_NOT_AUTHORIZED Routing_Error = 33
)

// Enum value maps for Routing_Error.
var (
	Routing_Error_name = map[int32]string{
		0:  "NONE",
		1:  "NO_ROUTE",
		2:  "GOT_NAK",
		3:  "TIMEOUT",
		4:  "NO_INTERFACE",
		5:  "MAX_RETRANSMIT",
		6:  "NO_CHANNEL",
		7:  "TOO_LARGE",
		8:  "NO_RESPONSE",
		32: "BAD_REQUEST",
		33: "NOT_AUTHORIZED",
	}
	Routing_Error_value = map[string]int32{
		"NONE":           0,
		"NO_ROUTE":       1,
		"GOT_NAK":        2,
		"TIMEOUT":        3,
		"NO_INTERFACE":   4,
		"MAX_RETRANSMIT": 5,
		"NO_CHANNEL":     6,
		"TOO_LARGE":      7,
		"NO_RESPONSE":    8,
		"BAD_REQUEST":    32,
		"NOT_AUTHORIZED": 33,
	}
)

func (x Routing_Error) Enum() *Routing_Error {
	p := new(Routing_Error)
	*p = x
	return p
}

func (x Routing_Error) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Routing_Error) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[3].Descriptor()
}

func (Routing_Error) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[3]
}

func (x Routing_Error) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Routing_Error.Descriptor instead.
func (Routing_Error) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{3, 0}
}

//
// The priority of this message for sending.  Higher priorities are sent first
// (when managing the transmit queue).
// This field is never sent over the air, it is only used internally inside of a local device node.
// API clients (either on the local node or connected directly to the node)
// can set this parameter if necessary.
//
// (values must be <= 127 to keep protobuf field to one byte in size.
//
// Detailed background on this field:
//
// I noticed a funny side effect of lora being so slow: Usually when making
// a protocol there isn’t much need to use message priority to change the order
// of transmission (because interfaces are fairly fast).
// But for lora where packets can take a few seconds each, it is very important
// to make sure that critical packets are sent ASAP.
// In the case of meshtastic that means we want to send protocol acks as soon as possible
// (to prevent unneeded retransmissions), we want routing messages to be sent next,
// then messages marked as reliable and finally ‘background’ packets like periodic position updates.
//
// So I bit the bullet and implemented a new (internal - not sent over the air)
// field in MeshPacket called ‘priority’.
// And the transmission queue in the router object is now a priority queue.
type MeshPacket_Priority int32

const (
	//
	// Treated as Priority.DEFAULT
	MeshPacket_UNSET MeshPacket_Priority = 0
	MeshPacket_MIN   MeshPacket_Priority = 1
	//
	// Background position updates are sent with very low priority -
	// if the link is super congested they might not go out at all
	MeshPacket_BACKGROUND MeshPacket_Priority = 10
	//
	// This priority is used for most messages that don't have a priority set
	MeshPacket_DEFAULT MeshPacket_Priority = 64
	//
	// If priority is unset but the message is marked as want_ack,
	// assume it is important and use a slightly higher priority
	MeshPacket_RELIABLE MeshPacket_Priority = 70
	//
	// Ack/naks are sent with very high priority to ensure that retransmission
	// stops as soon as possible
	MeshPacket_ACK MeshPacket_Priority = 120
	MeshPacket_MAX MeshPacket_Priority = 127
)

// Enum value maps for MeshPacket_Priority.
var (
	MeshPacket_Priority_name = map[int32]string{
		0:   "UNSET",
		1:   "MIN",
		10:  "BACKGROUND",
		64:  "DEFAULT",
		70:  "RELIABLE",
		120: "ACK",
		127: "MAX",
	}
	MeshPacket_Priority_value = map[string]int32{
		"UNSET":      0,
		"MIN":        1,
		"BACKGROUND": 10,
		"DEFAULT":    64,
		"RELIABLE":   70,
		"ACK":        120,
		"MAX":        127,
	}
)

func (x MeshPacket_Priority) Enum() *MeshPacket_Priority {
	p := new(MeshPacket_Priority)
	*p = x
	return p
}

func (x MeshPacket_Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[4].Descriptor()
}

func (MeshPacket_Priority) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[4]
}

func (x MeshPacket_Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Priority.Descriptor instead.
func (MeshPacket_Priority) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5, 0}
}

//
// Log levels, chosen to match python logging conventions.
type LogRecord_Level int32

const (
	LogRecord_UNSET    LogRecord_Level = 0
	LogRecord_CRITICAL LogRecord_Level = 50
	LogRecord_ERROR    LogRecord_Level = 40
	LogRecord_WARNING  LogRecord_Level = 30
	LogRecord_INFO     LogRecord_Level = 20
	LogRecord_DEBUG    LogRecord_Level = 10
	LogRecord_TRACE    LogRecord_Level = 5
)

// Enum value maps for LogRecord_Level.
var (
	LogRecord_Level_name = map[int32]string{
		0:  "UNSET",
		50: "CRITICAL",
		40: "ERROR",
		30: "WARNING",
		20: "INFO",
		10: "DEBUG",
		5:  "TRACE",
	}
	LogRecord_Level_value = map[string]int32{
		"UNSET":    0,
		"CRITICAL": 50,
		"ERROR":    40,
		"WARNING":  30,
		"INFO":     20,
		"DEBUG":    10,
		"TRACE":    5,
	}
)

func (x LogRecord_Level) Enum() *LogRecord_Level {
	p := new(LogRecord_Level)
	*p = x
	return p
}

func (x LogRecord_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogRecord_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[5].Descriptor()
}

func (LogRecord_Level) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[5]
}

func (x LogRecord_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogRecord_Level.Descriptor instead.
func (LogRecord_Level) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{8, 0}
}

//
// a gps position
type Position struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The new preferred location encoding, divide by 1e-7 to get degrees
	// in floating point
	LatitudeI  int32 `protobuf:"fixed32,1,opt,name=latitude_i,json=latitudeI,proto3" json:"latitude_i,omitempty"`
	LongitudeI int32 `protobuf:"fixed32,2,opt,name=longitude_i,json=longitudeI,proto3" json:"longitude_i,omitempty"`
	//
	// In meters above MSL
	Altitude int32 `protobuf:"varint,3,opt,name=altitude,proto3" json:"altitude,omitempty"`
	//
	// 1-100 (0 means not provided)
	BatteryLevel int32 `protobuf:"varint,4,opt,name=battery_level,json=batteryLevel,proto3" json:"battery_level,omitempty"`
	//
	// This is usually not sent over the mesh (to save space), but it is sent
	// from the phone so that the local device can set its RTC If it is sent over
	// the mesh (because there are devices on the mesh without GPS), it will only
	// be sent by devices which has a hardware GPS clock.
	// seconds since 1970
	Time uint32 `protobuf:"fixed32,9,opt,name=time,proto3" json:"time,omitempty"`
}

func (x *Position) Reset() {
	*x = Position{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil {
		return x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil {
		return x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil {
		return x.Altitude
	}
	return 0
}

func (x *Position) GetBatteryLevel() int32 {
	if x != nil {
		return x.BatteryLevel
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

//
// Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this node.
// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
//
// The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
// other nodes to reply with their User as well (so the new node can build its nodedb)
// If a node ever receives a User (not just the first broadcast) message where
// the sender node number equals our node number, that indicates a collision has
// occurred and the following steps should happen:
//
// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
// new User who just tried to sign in: it gets to keep its nodenum.  We send a
// broadcast message of OUR User (we use a broadcast so that the other node can
// receive our message, considering we have the same id - it also serves to let
// observers correct their nodedb) - this case is rare so it should be okay.
//
// If any node receives a User where the macaddr is GTE than their local macaddr,
// they have been vetoed and should pick a new random nodenum (filtering against
// whatever it knows about the nodedb) and rebroadcast their User.
//
// A few nodenums are reserved and will never be requested:
// 0xff - broadcast
// 0 through 3 - for future use
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// A globally unique ID string for this user.  In the case of
	// Signal that would mean +16504442323, for the default macaddr
	// derived id it would be !<8 hexidecimal bytes>
	// Note: app developers are encouraged to also use the following standard
	// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	//
	// A full name for this user, i.e. "Kevin Hester"
	LongName string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	//
	// A VERY short name, ideally two characters.  Suitable for a tiny OLED screen
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	//
	// This is the addr of the radio.  Not populated by the phone,
	// but added by the esp32 when broadcasting
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"`
	//
	// TBEAM, HELTEC, etc...
	// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.  Apps will still need the string here for older builds
	// (so OTA update can find the right image), but if the enum is available it will be used instead.
	HwModel HardwareModel `protobuf:"varint,6,opt,name=hw_model,json=hwModel,proto3,enum=HardwareModel" json:"hw_model,omitempty"`
	//
	// In some regions HAM radio operators have different bandwidth limitations than others.  If this user is a licensed operator,
	// set this flag.  Also, "long_name" should be their licence number.
	IsLicensed bool `protobuf:"varint,7,opt,name=is_licensed,json=isLicensed,proto3" json:"is_licensed,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

func (x *User) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *User) GetIsLicensed() bool {
	if x != nil {
		return x.IsLicensed
	}
	return false
}

//
// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
type RouteDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The list of nodenums this packet has visited so far
	Route []uint32 `protobuf:"fixed32,2,rep,packed,name=route,proto3" json:"route,omitempty"`
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *RouteDiscovery) GetRoute() []uint32 {
	if x != nil {
		return x.Route
	}
	return nil
}

//
//A Routing control Data packet handled by the routing plugin
type Routing struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//	*Routing_RouteRequest
	//	*Routing_RouteReply
	//	*Routing_ErrorReason
	Variant isRouting_Variant `protobuf_oneof:"variant"`
}

func (x *Routing) Reset() {
	*x = Routing{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Routing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Routing) ProtoMessage() {}

func (x *Routing) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Routing.ProtoReflect.Descriptor instead.
func (*Routing) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{3}
}

func (m *Routing) GetVariant() isRouting_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *Routing) GetRouteRequest() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteRequest); ok {
		return x.RouteRequest
	}
	return nil
}

func (x *Routing) GetRouteReply() *RouteDiscovery {
	if x, ok := x.GetVariant().(*Routing_RouteReply); ok {
		return x.RouteReply
	}
	return nil
}

func (x *Routing) GetErrorReason() Routing_Error {
	if x, ok := x.GetVariant().(*Routing_ErrorReason); ok {
		return x.ErrorReason
	}
	return Routing_NONE
}

type isRouting_Variant interface {
	isRouting_Variant()
}

type Routing_RouteRequest struct {
	//
	// A route request going from the requester
	RouteRequest *RouteDiscovery `protobuf:"bytes,1,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type Routing_RouteReply struct {
	//
	// A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,2,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type Routing_ErrorReason struct {
	//
	// A failure in delivering a message (usually used for routing control messages, but might be provided
	// in addition to ack.fail_id to provide details on the type of failure).
	ErrorReason Routing_Error `protobuf:"varint,3,opt,name=error_reason,json=errorReason,proto3,enum=Routing_Error,oneof"`
}

func (*Routing_RouteRequest) isRouting_Variant() {}

func (*Routing_RouteReply) isRouting_Variant() {}

func (*Routing_ErrorReason) isRouting_Variant() {}

//
// (Formerly called SubPacket)
// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Formerly named typ and of type Type
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=PortNum" json:"portnum,omitempty"`
	//
	// Required
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	//
	// Not normally used, but for testing a sender can request that recipient
	// responds in kind (i.e. if it received a position, it should unicast back it's position).
	// Note: that if you set this on a broadcast you will receive many replies.
	WantResponse bool `protobuf:"varint,3,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	//
	// The address of the destination node.
	// This field is is filled in by the mesh radio device software, application
	// layer software should never need it.
	// RouteDiscovery messages _must_ populate this.  Other message types might need
	// to if they are doing multihop routing.
	Dest uint32 `protobuf:"fixed32,4,opt,name=dest,proto3" json:"dest,omitempty"`
	//
	// The address of the original sender for this message.
	// This field should _only_ be populated for reliable multihop packets (to keep
	// packets small).
	Source uint32 `protobuf:"fixed32,5,opt,name=source,proto3" json:"source,omitempty"`
	//
	// Only used in routing or response messages.  Indicates the original message ID that
	// this message is reporting failure on. (formerly called original_id)
	RequestId uint32 `protobuf:"fixed32,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{4}
}

func (x *Data) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Data) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (x *Data) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *Data) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *Data) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

//
// A packet envelope sent/received over the mesh
// only payloadVariant is sent in the payload portion of the LORA packet.
// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
type MeshPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The sending node number.
	// Note: Our crypto implementation uses this field as well.  See
	// docs/software/crypto.md for details.
	// FIXME - really should be fixed32 instead, this encoding only hurts the ble link though.
	From uint32 `protobuf:"fixed32,1,opt,name=from,proto3" json:"from,omitempty"`
	//
	// The (immediatSee Priority description for more details.y should be fixed32 instead, this encoding only
	// hurts the ble link though.
	To uint32 `protobuf:"fixed32,2,opt,name=to,proto3" json:"to,omitempty"`
	//
	// (Usually) If set, this indicates the index in the secondary_channels table that this packet
	// was sent/received on.  If unset, packet was on the primary channel.
	// A particular node might know only a subset of channels in use on the mesh.  Therefore channel_index
	// is inherently a local concept and meaningless to send between nodes.
	// Very briefly, while sending and receiving deep inside the device Router code, this field instead
	// contains the 'channel hash' instead of the index.  This 'trick' is only used while the payloadVariant is
	// an 'encrypted'.
	Channel uint32 `protobuf:"varint,3,opt,name=channel,proto3" json:"channel,omitempty"`
	// Types that are assignable to PayloadVariant:
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	PayloadVariant isMeshPacket_PayloadVariant `protobuf_oneof:"payloadVariant"`
	//
	// A unique ID for this packet.  Always 0 for no-ack packets or non broadcast
	// packets (and therefore take zero bytes of space).  Otherwise a unique ID for
	// this packet, useful for flooding algorithms.
	// ID only needs to be unique on a _per sender_ basis, and it only
	// needs to be unique for a few minutes (long enough to last for the length of
	// any ACK or the completion of a mesh broadcast flood).
	// Note: Our crypto implementation uses this id as well.  See docs/software/crypto.md for details.
	// FIXME - really should be fixed32 instead, this encoding only
	// hurts the ble link though.
	Id uint32 `protobuf:"fixed32,6,opt,name=id,proto3" json:"id,omitempty"`
	//
	// The time this message was received by the esp32 (secs since 1970).  Note:
	// this field is _never_ sent on the radio link itself (to save space) Times
	// are typically not sent over the mesh, but they will be added to any Packet
	// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
	RxTime uint32 `protobuf:"fixed32,7,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	//
	// *Never* sent over the radio links.  Set during reception to indicate the SNR
	// of this packet.  Used to collect statistics on current link quality.
	RxSnr float32 `protobuf:"fixed32,8,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	//
	// If unset treated as zero (no forwarding, send to adjacent nodes only)
	// if 1, allow hopping through one node, etc...
	// For our usecase real world topologies probably have a max of about 3.
	// This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,10,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	//
	// This packet is being sent as a reliable message, we would prefer it to arrive
	// at the destination.  We would like to receive a ack packet in response.
	// Broadcasts messages treat this flag specially: Since acks for broadcasts would
	// rapidly flood the channel, the normal ack behavior is suppressed.  Instead,
	// the original sender listens to see if at least one node is rebroadcasting this
	// packet (because naive flooding algorithm).  If it hears that the odds (given
	// typical LoRa topologies) the odds are very high that every node should
	// eventually receive the message.  So FloodingRouter.cpp generates an implicit
	// ack which is delivered to the original sender. If after some time we don't
	// hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
	// Note: This flag is normally sent in a flag bit in the header when sent over the wire
	WantAck bool `protobuf:"varint,11,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	//
	// The priority of this message for sending.
	// See MeshPacket.Priority description for more details.
	Priority MeshPacket_Priority `protobuf:"varint,12,opt,name=priority,proto3,enum=MeshPacket_Priority" json:"priority,omitempty"`
	//
	// rssi of received packet. Only sent to phone for dispay purposes.
	RxRssi int32 `protobuf:"varint,13,opt,name=rx_rssi,json=rxRssi,proto3" json:"rx_rssi,omitempty"`
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *MeshPacket) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (m *MeshPacket) GetPayloadVariant() isMeshPacket_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *Data {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Decoded); ok {
		return x.Decoded
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x, ok := x.GetPayloadVariant().(*MeshPacket_Encrypted); ok {
		return x.Encrypted
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *MeshPacket) GetPriority() MeshPacket_Priority {
	if x != nil {
		return x.Priority
	}
	return MeshPacket_UNSET
}

func (x *MeshPacket) GetRxRssi() int32 {
	if x != nil {
		return x.RxRssi
	}
	return 0
}

type isMeshPacket_PayloadVariant interface {
	isMeshPacket_PayloadVariant()
}

type MeshPacket_Decoded struct {
	Decoded *Data `protobuf:"bytes,4,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	Encrypted []byte `protobuf:"bytes,5,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_PayloadVariant() {}

func (*MeshPacket_Encrypted) isMeshPacket_PayloadVariant() {}

//
// The bluetooth to device link:
//
// Old BTLE protocol docs from TODO, merge in above and make real docs...
//
// use protocol buffers, and NanoPB
//
// messages from device to phone:
// POSITION_UPDATE (..., time)
// TEXT_RECEIVED(from, text, time)
// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
//
// messages from phone to device:
// SET_MYID(id, human readable long, human readable short) (send down the unique ID
// string used for this node, a human readable string shown for that id, and a very
// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
// nodes() (returns list of nodes, with full info, last time seen, loc, battery
// level etc) SET_CONFIG (switches device to a new set of radio params and
// preshared key, drops all existing nodes, force our node to rejoin this new group)
//
// Full information about a node on the mesh
type NodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// the node number
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	//
	// The user info for this node
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	//
	// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time.
	// That is no longer true.  Position.time now indicates the last time we received a POSITION from that node.
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	//
	// Returns the Signal-to-noise ratio (SNR) of the last received message,
	// as measured by the receiver. Return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,7,opt,name=snr,proto3" json:"snr,omitempty"`
	//* Set to indicate the last time we received a packet from this node
	LastHeard uint32 `protobuf:"fixed32,4,opt,name=last_heard,json=lastHeard,proto3" json:"last_heard,omitempty"`
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetLastHeard() uint32 {
	if x != nil {
		return x.LastHeard
	}
	return 0
}

//
// Unique local debugging info for this node
// Note: we don't include position or the user info, because that will come in the
// Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Tells the phone what our node number is, default starting value is
	// lowbyte of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	//
	// Note: This flag merely means we detected a hardware GPS in our node.  Not the same as UserPreferences.location_sharing
	HasGps bool `protobuf:"varint,2,opt,name=has_gps,json=hasGps,proto3" json:"has_gps,omitempty"`
	//
	// # of frequencies that can be used (set at build time in the device flash image).  Note: this is different from max_channels, this field
	// is telling the # of frequency bands this node can use.  (old name was num_channels)
	NumBands uint32 `protobuf:"varint,3,opt,name=num_bands,json=numBands,proto3" json:"num_bands,omitempty"`
	//
	// The maximum number of 'software' channels that can be set on this node.
	MaxChannels uint32 `protobuf:"varint,15,opt,name=max_channels,json=maxChannels,proto3" json:"max_channels,omitempty"`
	//
	// Deprecated! ONLY USED IN DEVICE CODE (for upgrading old 1.0 firmwares) DO NOT READ ELSEWHERE.
	// The region code for my radio (US, CN, etc...)
	// Note: This string is deprecated.  The 1.0 builds populate it based on the
	// flashed firmware name.  But for newer builds this string will be unpopulated
	// (missing/null).  For those builds you should instead look at the new
	// read/write region enum in UserSettings
	// The format of this string was 1.0-US or 1.0-CN etc.. Or empty string if unset.
	//
	// Deprecated: Do not use.
	Region string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	//
	// TBEAM, HELTEC, etc...
	// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.  Apps will still need the string here for older builds
	// (so OTA update can find the right image), but if the enum is available it will be used instead.
	//
	// Deprecated: Do not use.
	HwModelDeprecated string `protobuf:"bytes,5,opt,name=hw_model_deprecated,json=hwModelDeprecated,proto3" json:"hw_model_deprecated,omitempty"`
	//
	// 0.0.5 etc...
	FirmwareVersion string `protobuf:"bytes,6,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	//
	// An error message we'd like to report back to the mothership through analytics.
	// It indicates a serious bug occurred on the device, the device coped with it,
	// but we still want to tell the devs about the bug.
	// This field will be cleared after the phone reads MyNodeInfo
	// (i.e. it will only be reported once)
	// a numeric error code to go with error message, zero means no error
	ErrorCode CriticalErrorCode `protobuf:"varint,7,opt,name=error_code,json=errorCode,proto3,enum=CriticalErrorCode" json:"error_code,omitempty"`
	//
	// A numeric error address (nonzero if available)
	ErrorAddress uint32 `protobuf:"varint,8,opt,name=error_address,json=errorAddress,proto3" json:"error_address,omitempty"`
	//
	// The total number of errors this node has ever encountered
	// (well - since the last time we discarded preferences)
	ErrorCount uint32 `protobuf:"varint,9,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	//
	// The total number of reboots this node has ever encountered
	// (well - since the last time we discarded preferences)
	RebootCount uint32 `protobuf:"varint,10,opt,name=reboot_count,json=rebootCount,proto3" json:"reboot_count,omitempty"`
	//
	// How long before we consider a message abandoned and we can clear our
	// caches of any messages in flight Normally quite large to handle the worst case
	// message delivery time, 5 minutes.  Formerly called FLOOD_EXPIRE_TIME in the
	// device code
	MessageTimeoutMsec uint32 `protobuf:"varint,13,opt,name=message_timeout_msec,json=messageTimeoutMsec,proto3" json:"message_timeout_msec,omitempty"`
	//
	// The minimum app version that can talk to this device.  Phone/PC apps should
	// compare this to their build number and if too low tell the user they must
	// update their app
	MinAppVersion uint32 `protobuf:"varint,14,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetHasGps() bool {
	if x != nil {
		return x.HasGps
	}
	return false
}

func (x *MyNodeInfo) GetNumBands() uint32 {
	if x != nil {
		return x.NumBands
	}
	return 0
}

func (x *MyNodeInfo) GetMaxChannels() uint32 {
	if x != nil {
		return x.MaxChannels
	}
	return 0
}

// Deprecated: Do not use.
func (x *MyNodeInfo) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

// Deprecated: Do not use.
func (x *MyNodeInfo) GetHwModelDeprecated() string {
	if x != nil {
		return x.HwModelDeprecated
	}
	return ""
}

func (x *MyNodeInfo) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *MyNodeInfo) GetErrorCode() CriticalErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return CriticalErrorCode_None
}

func (x *MyNodeInfo) GetErrorAddress() uint32 {
	if x != nil {
		return x.ErrorAddress
	}
	return 0
}

func (x *MyNodeInfo) GetErrorCount() uint32 {
	if x != nil {
		return x.ErrorCount
	}
	return 0
}

func (x *MyNodeInfo) GetRebootCount() uint32 {
	if x != nil {
		return x.RebootCount
	}
	return 0
}

func (x *MyNodeInfo) GetMessageTimeoutMsec() uint32 {
	if x != nil {
		return x.MessageTimeoutMsec
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

//
// Debug output from the device.
//
// To minimize the size of records inside the device code, if a time/source/level is not set
// on the message it is assumed to be a continuation of the previously sent message.
// This allows the device code to use fixed maxlen 64 byte strings for messages,
// and then extend as needed by emitting multiple records.
type LogRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	//
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	//
	// Usually based on thread name - if known
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	//
	// Not yet set
	Level LogRecord_Level `protobuf:"varint,4,opt,name=level,proto3,enum=LogRecord_Level" json:"level,omitempty"`
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *LogRecord) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogRecord) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogRecord) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *LogRecord) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

//
// Packets from the radio to the phone will appear on the fromRadio characteristic.
// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
// It will sit in that descriptor until consumed by the phone,
// at which point the next item in the FIFO will be populated.
type FromRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The packet num, used to allow the phone to request missing read packets from the FIFO,
	// see our bluetooth docs
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// Types that are assignable to PayloadVariant:
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_LogRecord
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	PayloadVariant isFromRadio_PayloadVariant `protobuf_oneof:"payloadVariant"`
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *FromRadio) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (m *FromRadio) GetPayloadVariant() isFromRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_MyInfo); ok {
		return x.MyInfo
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x, ok := x.GetPayloadVariant().(*FromRadio_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (x *FromRadio) GetLogRecord() *LogRecord {
	if x, ok := x.GetPayloadVariant().(*FromRadio_LogRecord); ok {
		return x.LogRecord
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x, ok := x.GetPayloadVariant().(*FromRadio_ConfigCompleteId); ok {
		return x.ConfigCompleteId
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x, ok := x.GetPayloadVariant().(*FromRadio_Rebooted); ok {
		return x.Rebooted
	}
	return false
}

type isFromRadio_PayloadVariant interface {
	isFromRadio_PayloadVariant()
}

type FromRadio_Packet struct {
	Packet *MeshPacket `protobuf:"bytes,11,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	//
	// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	//
	// One packet is sent for each node in the on radio DB
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_LogRecord struct {
	//
	// set to send debug console output over our protobuf stream
	LogRecord *LogRecord `protobuf:"bytes,7,opt,name=log_record,json=logRecord,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	//
	// sent as true once the device has finished sending all of the responses to want_config
	// recipient should check if this ID matches our original request nonce, if
	// not, it means your config responses haven't started yet.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	ConfigCompleteId uint32 `protobuf:"varint,8,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	//
	// Sent to tell clients the radio has just rebooted.  Set to true if present.
	// Not used on all transports, currently just used for the serial console.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	Rebooted bool `protobuf:"varint,9,opt,name=rebooted,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_PayloadVariant() {}

func (*FromRadio_MyInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_NodeInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_LogRecord) isFromRadio_PayloadVariant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_PayloadVariant() {}

func (*FromRadio_Rebooted) isFromRadio_PayloadVariant() {}

//
// packets/commands to the radio will be written (reliably) to the toRadio characteristic.
// Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to PayloadVariant:
	//	*ToRadio_Packet
	//	*ToRadio_PeerInfo_
	//	*ToRadio_WantConfigId
	//	*ToRadio_Disconnect
	PayloadVariant isToRadio_PayloadVariant `protobuf_oneof:"payloadVariant"`
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{10}
}

func (m *ToRadio) GetPayloadVariant() isToRadio_PayloadVariant {
	if m != nil {
		return m.PayloadVariant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *ToRadio) GetPeerInfo() *ToRadio_PeerInfo {
	if x, ok := x.GetPayloadVariant().(*ToRadio_PeerInfo_); ok {
		return x.PeerInfo
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x, ok := x.GetPayloadVariant().(*ToRadio_WantConfigId); ok {
		return x.WantConfigId
	}
	return 0
}

func (x *ToRadio) GetDisconnect() bool {
	if x, ok := x.GetPayloadVariant().(*ToRadio_Disconnect); ok {
		return x.Disconnect
	}
	return false
}

type isToRadio_PayloadVariant interface {
	isToRadio_PayloadVariant()
}

type ToRadio_Packet struct {
	//
	// send this packet on the mesh
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type ToRadio_PeerInfo_ struct {
	//
	// Information about the peer, sent after the phone sneds want_config_id.  Old clients do not send this, which is fine.
	PeerInfo *ToRadio_PeerInfo `protobuf:"bytes,3,opt,name=peer_info,json=peerInfo,proto3,oneof"`
}

type ToRadio_WantConfigId struct {
	//
	// phone wants radio to send full node db to the phone, This is
	// typically the first packet sent to the radio when the phone gets a
	// bluetooth connection. The radio will respond by sending back a
	// MyNodeInfo, a owner, a radio config and a series of
	// FromRadio.node_infos, and config_complete
	// the integer you write into this field will be reported back in the
	// config_complete_id response this allows clients to never be confused by
	// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,100,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_Disconnect struct {
	//
	// Tell API server we are disconnecting now.  This is useful for serial links where there is no hardware/protocol based
	// notification that the client has dropped the link.
	// (Sending this message is optional for clients)
	Disconnect bool `protobuf:"varint,104,opt,name=disconnect,proto3,oneof"`
}

func (*ToRadio_Packet) isToRadio_PayloadVariant() {}

func (*ToRadio_PeerInfo_) isToRadio_PayloadVariant() {}

func (*ToRadio_WantConfigId) isToRadio_PayloadVariant() {}

func (*ToRadio_Disconnect) isToRadio_PayloadVariant() {}

//
// Instead of sending want_config_id as a uint32, newer clients send this structure with information about the client.
type ToRadio_PeerInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// The numeric version code for the client application, which in some cases are used to control device behavior (so the device can
	// make assumptions about who is using the API.
	AppVersion uint32 `protobuf:"varint,1,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	//
	// True if the peer device can gateway MQTT packets.  If true, the device will not try to send packets to the internet directly,
	// instead it will pass the packets to the peer for dispatching.
	// This feature is optional, if set to false the device will assume the client can not gateway to MQTT.
	MqttGateway bool `protobuf:"varint,2,opt,name=mqtt_gateway,json=mqttGateway,proto3" json:"mqtt_gateway,omitempty"`
}

func (x *ToRadio_PeerInfo) Reset() {
	*x = ToRadio_PeerInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio_PeerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio_PeerInfo) ProtoMessage() {}

func (x *ToRadio_PeerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio_PeerInfo.ProtoReflect.Descriptor instead.
func (*ToRadio_PeerInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{10, 0}
}

func (x *ToRadio_PeerInfo) GetAppVersion() uint32 {
	if x != nil {
		return x.AppVersion
	}
	return 0
}

func (x *ToRadio_PeerInfo) GetMqttGateway() bool {
	if x != nil {
		return x.MqttGateway
	}
	return false
}

var File_mesh_proto protoreflect.FileDescriptor

var file_mesh_proto_rawDesc = []byte{
	0x0a, 0x0a, 0x6d, 0x65, 0x73, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x0e, 0x70, 0x6f,
	0x72, 0x74, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xab, 0x01, 0x0a,
	0x08, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x09, 0x6c,
	0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0f, 0x52, 0x0a, 0x6c,
	0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79,
	0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x62, 0x61,
	0x74, 0x74, 0x65, 0x72, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x4a, 0x04,
	0x08, 0x07, 0x10, 0x08, 0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x22, 0xb8, 0x01, 0x0a, 0x04, 0x55,
	0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x4e, 0x61, 0x6d, 0x65,
	0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x18, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x07, 0x6d, 0x61, 0x63, 0x61, 0x64, 0x64, 0x72, 0x12, 0x29, 0x0a, 0x08, 0x68, 0x77, 0x5f,
	0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x48, 0x61,
	0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x07, 0x68, 0x77, 0x4d,
	0x6f, 0x64, 0x65, 0x6c, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e,
	0x73, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x4c, 0x69, 0x63,
	0x65, 0x6e, 0x73, 0x65, 0x64, 0x22, 0x26, 0x0a, 0x0e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69,
	0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x07, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x22, 0xec, 0x02,
	0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x36, 0x0a, 0x0d, 0x72, 0x6f, 0x75,
	0x74, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0f, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
	0x79, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x32, 0x0a, 0x0b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x70, 0x6c, 0x79,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69,
	0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f, 0x75, 0x74, 0x65,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x33, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72,
	0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x52, 0x6f,
	0x75, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0b, 0x65,
	0x72, 0x72, 0x6f, 0x72, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x22, 0xb4, 0x01, 0x0a, 0x05, 0x45,
	0x72, 0x72, 0x6f, 0x72, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x0c,
	0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07,
	0x47, 0x4f, 0x54, 0x5f, 0x4e, 0x41, 0x4b, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x54, 0x49, 0x4d,
	0x45, 0x4f, 0x55, 0x54, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c, 0x4e, 0x4f, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x52, 0x46, 0x41, 0x43, 0x45, 0x10, 0x04, 0x12, 0x12, 0x0a, 0x0e, 0x4d, 0x41, 0x58, 0x5f,
	0x52, 0x45, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x4d, 0x49, 0x54, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a,
	0x4e, 0x4f, 0x5f, 0x43, 0x48, 0x41, 0x4e, 0x4e, 0x45, 0x4c, 0x10, 0x06, 0x12, 0x0d, 0x0a, 0x09,
	0x54, 0x4f, 0x4f, 0x5f, 0x4c, 0x41, 0x52, 0x47, 0x45, 0x10, 0x07, 0x12, 0x0f, 0x0a, 0x0b, 0x4e,
	0x4f, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x08, 0x12, 0x0f, 0x0a, 0x0b,
	0x42, 0x41, 0x44, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x10, 0x20, 0x12, 0x12, 0x0a,
	0x0e, 0x4e, 0x4f, 0x54, 0x5f, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x45, 0x44, 0x10,
	0x21, 0x42, 0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0xb4, 0x01, 0x0a,
	0x04, 0x44, 0x61, 0x74, 0x61, 0x12, 0x22, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x08, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4e, 0x75, 0x6d,
	0x52, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x6e, 0x75, 0x6d, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c,
	0x6f, 0x61, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x49, 0x64, 0x22, 0xbf, 0x03, 0x0a, 0x0a, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b,
	0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07,
	0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x07, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
	0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
	0x12, 0x21, 0x0a, 0x07, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x05, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x07, 0x64, 0x65, 0x63, 0x6f,
	0x64, 0x65, 0x64, 0x12, 0x1e, 0x0a, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x07, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x72, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x06,
	0x72, 0x78, 0x5f, 0x73, 0x6e, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x72, 0x78,
	0x53, 0x6e, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x12, 0x19, 0x0a, 0x08, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x61, 0x63, 0x6b, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x77, 0x61, 0x6e, 0x74, 0x41, 0x63, 0x6b, 0x12, 0x30, 0x0a, 0x08, 0x70,
	0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x14, 0x2e,
	0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x50, 0x72, 0x69, 0x6f, 0x72,
	0x69, 0x74, 0x79, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x17, 0x0a,
	0x07, 0x72, 0x78, 0x5f, 0x72, 0x73, 0x73, 0x69, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06,
	0x72, 0x78, 0x52, 0x73, 0x73, 0x69, 0x22, 0x5b, 0x0a, 0x08, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69,
	0x74, 0x79, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x07, 0x0a,
	0x03, 0x4d, 0x49, 0x4e, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x42, 0x41, 0x43, 0x4b, 0x47, 0x52,
	0x4f, 0x55, 0x4e, 0x44, 0x10, 0x0a, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c,
	0x54, 0x10, 0x40, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x45, 0x4c, 0x49, 0x41, 0x42, 0x4c, 0x45, 0x10,
	0x46, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x43, 0x4b, 0x10, 0x78, 0x12, 0x07, 0x0a, 0x03, 0x4d, 0x41,
	0x58, 0x10, 0x7f, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x56, 0x61,
	0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x8f, 0x01, 0x0a, 0x08, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x03, 0x6e, 0x75, 0x6d, 0x12, 0x19, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12,
	0x25, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x09, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x02, 0x52, 0x03, 0x73, 0x6e, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x73, 0x74,
	0x5f, 0x68, 0x65, 0x61, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x52, 0x09, 0x6c, 0x61,
	0x73, 0x74, 0x48, 0x65, 0x61, 0x72, 0x64, 0x22, 0xf6, 0x03, 0x0a, 0x0a, 0x4d, 0x79, 0x4e, 0x6f,
	0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1e, 0x0a, 0x0b, 0x6d, 0x79, 0x5f, 0x6e, 0x6f, 0x64,
	0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6d, 0x79, 0x4e,
	0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x17, 0x0a, 0x07, 0x68, 0x61, 0x73, 0x5f, 0x67, 0x70,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x68, 0x61, 0x73, 0x47, 0x70, 0x73, 0x12,
	0x1b, 0x0a, 0x09, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x08, 0x6e, 0x75, 0x6d, 0x42, 0x61, 0x6e, 0x64, 0x73, 0x12, 0x21, 0x0a, 0x0c,
	0x6d, 0x61, 0x78, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x0f, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0b, 0x6d, 0x61, 0x78, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12,
	0x1a, 0x0a, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x02, 0x18, 0x01, 0x52, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x12, 0x32, 0x0a, 0x13, 0x68,
	0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74,
	0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x02, 0x18, 0x01, 0x52, 0x11, 0x68, 0x77,
	0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x12,
	0x29, 0x0a, 0x10, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d, 0x77,
	0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x31, 0x0a, 0x0a, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12,
	0x2e, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f,
	0x64, 0x65, 0x52, 0x09, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x23, 0x0a,
	0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x5f, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x72, 0x65, 0x62, 0x6f, 0x6f,
	0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x6d, 0x73, 0x65, 0x63, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x4d, 0x73, 0x65, 0x63, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f,
	0x61, 0x70, 0x70, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0e, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x41, 0x70, 0x70, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x22, 0xd3, 0x01, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x18,
	0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69, 0x6d, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x12, 0x26, 0x0a, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x2e,
	0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x05, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x22, 0x58, 0x0a, 0x05,
	0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00,
	0x12, 0x0c, 0x0a, 0x08, 0x43, 0x52, 0x49, 0x54, 0x49, 0x43, 0x41, 0x4c, 0x10, 0x32, 0x12, 0x09,
	0x0a, 0x05, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x28, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x41, 0x52,
	0x4e, 0x49, 0x4e, 0x47, 0x10, 0x1e, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x4e, 0x46, 0x4f, 0x10, 0x14,
	0x12, 0x09, 0x0a, 0x05, 0x44, 0x45, 0x42, 0x55, 0x47, 0x10, 0x0a, 0x12, 0x09, 0x0a, 0x05, 0x54,
	0x52, 0x41, 0x43, 0x45, 0x10, 0x05, 0x22, 0xaf, 0x02, 0x0a, 0x09, 0x46, 0x72, 0x6f, 0x6d, 0x52,
	0x61, 0x64, 0x69, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x25, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63,
	0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x26, 0x0a,
	0x07, 0x6d, 0x79, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b,
	0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6d,
	0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x28, 0x0a, 0x09, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49,
	0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x2b, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x48,
	0x00, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x2e, 0x0a, 0x12,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x5f,
	0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x10, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x08,
	0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00,
	0x52, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x4a, 0x04, 0x08, 0x02,
	0x10, 0x03, 0x4a, 0x04, 0x08, 0x06, 0x10, 0x07, 0x22, 0xa6, 0x02, 0x0a, 0x07, 0x54, 0x6f, 0x52,
	0x61, 0x64, 0x69, 0x6f, 0x12, 0x25, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65,
	0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x30, 0x0a, 0x09, 0x70,
	0x65, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11,
	0x2e, 0x54, 0x6f, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x49, 0x6e, 0x66,
	0x6f, 0x48, 0x00, 0x52, 0x08, 0x70, 0x65, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x0a,
	0x0e, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x69, 0x64, 0x18,
	0x64, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0a, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e,
	0x65, 0x63, 0x74, 0x18, 0x68, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x0a, 0x64, 0x69, 0x73,
	0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x1a, 0x4e, 0x0a, 0x08, 0x50, 0x65, 0x65, 0x72, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x70, 0x70, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x61, 0x70, 0x70, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x6d, 0x71, 0x74, 0x74, 0x5f, 0x67, 0x61, 0x74,
	0x65, 0x77, 0x61, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x6d, 0x71, 0x74, 0x74,
	0x47, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6c, 0x6f,
	0x61, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02, 0x4a,
	0x04, 0x08, 0x65, 0x10, 0x66, 0x4a, 0x04, 0x08, 0x66, 0x10, 0x67, 0x4a, 0x04, 0x08, 0x67, 0x10,
	0x68, 0x2a, 0x8a, 0x02, 0x0a, 0x0d, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x4d, 0x6f,
	0x64, 0x65, 0x6c, 0x12, 0x09, 0x0a, 0x05, 0x55, 0x4e, 0x53, 0x45, 0x54, 0x10, 0x00, 0x12, 0x0c,
	0x0a, 0x08, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08,
	0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x31, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x4c,
	0x4f, 0x52, 0x41, 0x5f, 0x56, 0x32, 0x5f, 0x31, 0x5f, 0x31, 0x70, 0x36, 0x10, 0x03, 0x12, 0x09,
	0x0a, 0x05, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x48, 0x45, 0x4c,
	0x54, 0x45, 0x43, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x42, 0x45, 0x41, 0x4d, 0x30, 0x70,
	0x37, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x54, 0x5f, 0x45, 0x43, 0x48, 0x4f, 0x10, 0x07, 0x12,
	0x10, 0x0a, 0x0c, 0x54, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x56, 0x31, 0x5f, 0x31, 0x70, 0x33, 0x10,
	0x08, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x41, 0x4b, 0x34, 0x36, 0x33, 0x31, 0x10, 0x09, 0x12, 0x11,
	0x0a, 0x0d, 0x4c, 0x4f, 0x52, 0x41, 0x5f, 0x52, 0x45, 0x4c, 0x41, 0x59, 0x5f, 0x56, 0x31, 0x10,
	0x20, 0x12, 0x0e, 0x0a, 0x0a, 0x4e, 0x52, 0x46, 0x35, 0x32, 0x38, 0x34, 0x30, 0x44, 0x4b, 0x10,
	0x21, 0x12, 0x07, 0x0a, 0x03, 0x50, 0x50, 0x52, 0x10, 0x22, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x45,
	0x4e, 0x49, 0x45, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x53, 0x10, 0x23, 0x12, 0x11, 0x0a, 0x0d, 0x4e,
	0x52, 0x46, 0x35, 0x32, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x24, 0x12, 0x0d,
	0x0a, 0x09, 0x50, 0x4f, 0x52, 0x54, 0x44, 0x55, 0x49, 0x4e, 0x4f, 0x10, 0x25, 0x12, 0x0f, 0x0a,
	0x0b, 0x41, 0x4e, 0x44, 0x52, 0x4f, 0x49, 0x44, 0x5f, 0x53, 0x49, 0x4d, 0x10, 0x26, 0x2a, 0x2e,
	0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x0a, 0x0a, 0x06, 0x55,
	0x6e, 0x75, 0x73, 0x65, 0x64, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x10, 0x44, 0x41, 0x54, 0x41, 0x5f,
	0x50, 0x41, 0x59, 0x4c, 0x4f, 0x41, 0x44, 0x5f, 0x4c, 0x45, 0x4e, 0x10, 0xf0, 0x01, 0x2a, 0xbd,
	0x01, 0x0a, 0x11, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72,
	0x43, 0x6f, 0x64, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12, 0x0e,
	0x0a, 0x0a, 0x54, 0x78, 0x57, 0x61, 0x74, 0x63, 0x68, 0x64, 0x6f, 0x67, 0x10, 0x01, 0x12, 0x12,
	0x0a, 0x0e, 0x53, 0x6c, 0x65, 0x65, 0x70, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x57, 0x61, 0x69, 0x74,
	0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x4e, 0x6f, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x10, 0x03, 0x12,
	0x0f, 0x0a, 0x0b, 0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x10, 0x04,
	0x12, 0x13, 0x0a, 0x0f, 0x55, 0x42, 0x6c, 0x6f, 0x78, 0x49, 0x6e, 0x69, 0x74, 0x46, 0x61, 0x69,
	0x6c, 0x65, 0x64, 0x10, 0x05, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x6f, 0x41, 0x58, 0x50, 0x31, 0x39,
	0x32, 0x10, 0x06, 0x12, 0x17, 0x0a, 0x13, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x52, 0x61,
	0x64, 0x69, 0x6f, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x10, 0x07, 0x12, 0x12, 0x0a, 0x0e,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x10, 0x08,
	0x12, 0x0c, 0x0a, 0x08, 0x42, 0x72, 0x6f, 0x77, 0x6e, 0x6f, 0x75, 0x74, 0x10, 0x09, 0x42, 0x45,
	0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x65, 0x65, 0x6b, 0x73, 0x76, 0x69, 0x6c, 0x6c, 0x65,
	0x2e, 0x6d, 0x65, 0x73, 0x68, 0x42, 0x0a, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x73, 0x48, 0x03, 0x5a, 0x20, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x6c, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x37, 0x2f, 0x6d, 0x65, 0x73, 0x68, 0x74, 0x61, 0x73, 0x74,
	0x69, 0x63, 0x2d, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_mesh_proto_rawDescOnce sync.Once
	file_mesh_proto_rawDescData = file_mesh_proto_rawDesc
)

func file_mesh_proto_rawDescGZIP() []byte {
	file_mesh_proto_rawDescOnce.Do(func() {
		file_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(file_mesh_proto_rawDescData)
	})
	return file_mesh_proto_rawDescData
}

var file_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_mesh_proto_goTypes = []interface{}{
	(HardwareModel)(0),       // 0: HardwareModel
	(Constants)(0),           // 1: Constants
	(CriticalErrorCode)(0),   // 2: CriticalErrorCode
	(Routing_Error)(0),       // 3: Routing.Error
	(MeshPacket_Priority)(0), // 4: MeshPacket.Priority
	(LogRecord_Level)(0),     // 5: LogRecord.Level
	(*Position)(nil),         // 6: Position
	(*User)(nil),             // 7: User
	(*RouteDiscovery)(nil),   // 8: RouteDiscovery
	(*Routing)(nil),          // 9: Routing
	(*Data)(nil),             // 10: Data
	(*MeshPacket)(nil),       // 11: MeshPacket
	(*NodeInfo)(nil),         // 12: NodeInfo
	(*MyNodeInfo)(nil),       // 13: MyNodeInfo
	(*LogRecord)(nil),        // 14: LogRecord
	(*FromRadio)(nil),        // 15: FromRadio
	(*ToRadio)(nil),          // 16: ToRadio
	(*ToRadio_PeerInfo)(nil), // 17: ToRadio.PeerInfo
	(PortNum)(0),             // 18: PortNum
}
var file_mesh_proto_depIdxs = []int32{
	0,  // 0: User.hw_model:type_name -> HardwareModel
	8,  // 1: Routing.route_request:type_name -> RouteDiscovery
	8,  // 2: Routing.route_reply:type_name -> RouteDiscovery
	3,  // 3: Routing.error_reason:type_name -> Routing.Error
	18, // 4: Data.portnum:type_name -> PortNum
	10, // 5: MeshPacket.decoded:type_name -> Data
	4,  // 6: MeshPacket.priority:type_name -> MeshPacket.Priority
	7,  // 7: NodeInfo.user:type_name -> User
	6,  // 8: NodeInfo.position:type_name -> Position
	2,  // 9: MyNodeInfo.error_code:type_name -> CriticalErrorCode
	5,  // 10: LogRecord.level:type_name -> LogRecord.Level
	11, // 11: FromRadio.packet:type_name -> MeshPacket
	13, // 12: FromRadio.my_info:type_name -> MyNodeInfo
	12, // 13: FromRadio.node_info:type_name -> NodeInfo
	14, // 14: FromRadio.log_record:type_name -> LogRecord
	11, // 15: ToRadio.packet:type_name -> MeshPacket
	17, // 16: ToRadio.peer_info:type_name -> ToRadio.PeerInfo
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_mesh_proto_init() }
func file_mesh_proto_init() {
	if File_mesh_proto != nil {
		return
	}
	file_portnums_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_mesh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Position); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteDiscovery); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Routing); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MeshPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MyNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LogRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FromRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio_PeerInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_mesh_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*Routing_RouteRequest)(nil),
		(*Routing_RouteReply)(nil),
		(*Routing_ErrorReason)(nil),
	}
	file_mesh_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_mesh_proto_msgTypes[9].OneofWrappers = []interface{}{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_LogRecord)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
	}
	file_mesh_proto_msgTypes[10].OneofWrappers = []interface{}{
		(*ToRadio_Packet)(nil),
		(*ToRadio_PeerInfo_)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_Disconnect)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_mesh_proto_rawDesc,
			NumEnums:      6,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mesh_proto_goTypes,
		DependencyIndexes: file_mesh_proto_depIdxs,
		EnumInfos:         file_mesh_proto_enumTypes,
		MessageInfos:      file_mesh_proto_msgTypes,
	}.Build()
	File_mesh_proto = out.File
	file_mesh_proto_rawDesc = nil
	file_mesh_proto_goTypes = nil
	file_mesh_proto_depIdxs = nil
}
